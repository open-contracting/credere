import json
import os
import uuid
from contextlib import contextmanager
from datetime import datetime
from typing import Any, Generator
from unittest.mock import MagicMock, patch

import boto3
import moto
import pytest
from botocore.config import Config
from fastapi import FastAPI
from fastapi.testclient import TestClient
from sqlalchemy import create_engine

from app import aws, dependencies, main, models
from app.db import get_db
from app.settings import app_settings
from tests import create_user, get_test_db


@pytest.fixture(scope="session")
def app() -> Generator[FastAPI, Any, None]:
    yield main.app


@pytest.fixture(scope="session")
def engine():
    return create_engine(os.getenv("TEST_DATABASE_URL"))


# http://docs.getmoto.org/en/latest/docs/getting_started.html#example-on-usage
@pytest.fixture(scope="session", autouse=True)
def aws_credentials():
    os.environ["AWS_ACCESS_KEY_ID"] = "testing"
    os.environ["AWS_SECRET_ACCESS_KEY"] = "testing"
    os.environ["AWS_SECURITY_TOKEN"] = "testing"
    os.environ["AWS_SESSION_TOKEN"] = "testing"
    os.environ["AWS_DEFAULT_REGION"] = "us-east-1"


# Setting "session" scope causes test failures, because users, etc. that are not expected to exist do exist.
@pytest.fixture(autouse=True)
def mock_aws(aws_credentials):
    # http://docs.getmoto.org/en/latest/docs/services/cognito-idp.html
    with moto.mock_aws():
        yield


# IMPORTANT! All calls to aws.ses_client must be mocked.
#
# Setting "session" scope and calling `mock_send_templated_email.reset_mock()` at the start of tests saves little time.
@pytest.fixture(autouse=True)
def mock_send_templated_email(mock_aws):
    with patch.object(aws.ses_client, "send_templated_email", MagicMock()) as mock:
        mock.return_value = {"MessageId": "123"}

        yield mock

        # Ensure all tags are replaced.
        for call in mock.mock_calls:
            assert "{{" not in json.loads(call.kwargs["TemplateData"])["CONTENT"]


@pytest.fixture(scope="session", autouse=True)
def database(engine):
    models.SQLModel.metadata.create_all(engine)
    yield
    models.SQLModel.metadata.drop_all(engine)


@pytest.fixture
def reset_database(engine):
    models.SQLModel.metadata.drop_all(engine)
    models.SQLModel.metadata.create_all(engine)
    yield
    models.SQLModel.metadata.drop_all(engine)
    models.SQLModel.metadata.create_all(engine)


@pytest.fixture
def sessionmaker(engine):
    return get_test_db(engine)


@pytest.fixture
def session(sessionmaker):
    with contextmanager(sessionmaker)() as db_session:
        yield db_session


@pytest.fixture
def aws_client(mock_aws):
    config = Config(region_name=app_settings.aws_region)

    cognito_client = boto3.client("cognito-idp", config=config)
    cognito_pool_id = cognito_client.create_user_pool(PoolName="TestUserPool")["UserPool"]["Id"]
    cognito_client.set_user_pool_mfa_config(
        UserPoolId=cognito_pool_id, SoftwareTokenMfaConfiguration={"Enabled": True}, MfaConfiguration="ON"
    )
    app_settings.cognito_pool_id = cognito_pool_id
    app_settings.cognito_client_id = cognito_client.create_user_pool_client(
        UserPoolId=cognito_pool_id, ClientName="TestAppClient"
    )["UserPoolClient"]["ClientId"]
    app_settings.cognito_client_secret = "secret"

    ses_client = boto3.client("ses", config=config)
    ses_client.verify_email_identity(EmailAddress=app_settings.email_sender_address)
    for key in ("-es", ""):
        ses_client.create_template(
            Template={
                "TemplateName": f"credere-main{key}",
                "SubjectPart": "Your email subject",
                "HtmlPart": "<html><body>Your HTML content</body></html>",
                "TextPart": "Your plain text content",
            }
        )

    yield aws.Client(
        cognito_client,
        ses_client,
        lambda: "initial-autogenerated-password",
    )


@pytest.fixture
def client(app: FastAPI, engine, aws_client) -> Generator[TestClient, Any, None]:
    # Mock dependencies. aws.client is used only in get_aws_client().
    app.dependency_overrides[dependencies.get_aws_client] = lambda: aws_client
    app.dependency_overrides[get_db] = get_test_db(engine)

    with TestClient(app) as client:
        yield client


@pytest.fixture
def lender(session):
    instance = models.Lender.create(
        session,
        name=str(uuid.uuid4()),
        email_group="test@example.com",
        type="Some Type",
        sla_days=7,
        status="Active",
    )
    session.commit()
    return instance


@pytest.fixture
def unauthorized_lender(session):
    instance = models.Lender.create(
        session,
        name=str(uuid.uuid4()),
        email_group="test@example.com",
        type="Some Type",
        sla_days=7,
        status="Active",
    )
    session.commit()
    return instance


@pytest.fixture
def admin_header(session, aws_client):
    return create_user(
        session,
        aws_client,
        email=f"ocp-test-{uuid.uuid4()}@open-contracting.org",
        name="OCP Test User",
        type=models.UserType.OCP,
    )


@pytest.fixture
def lender_header(session, aws_client, lender):
    return create_user(
        session,
        aws_client,
        email=f"lender-user-{uuid.uuid4()}@example.com",
        name="Lender Test User",
        type=models.UserType.FI,
        lender=lender,
    )


@pytest.fixture
def unauthorized_lender_header(session, aws_client, unauthorized_lender):
    return create_user(
        session,
        aws_client,
        email=f"lender-user-{uuid.uuid4()}@example.com",
        name="Lender Test User",
        type=models.UserType.FI,
        lender=unauthorized_lender,
    )


@pytest.fixture
def user_payload():
    return {
        "email": f"test-{uuid.uuid4()}@noreply.open-contracting.org",
        "name": "Test User",
        "type": models.UserType.FI,
    }


@pytest.fixture
def credit_product(session, lender):
    instance = models.CreditProduct.create(
        session,
        borrower_size=models.BorrowerSize.SMALL,
        lower_limit=5000.00,
        upper_limit=500000.00,
        type=models.CreditType.LOAN,
        required_document_types={
            "INCORPORATION_DOCUMENT": True,
        },
        # Descriptive
        interest_rate=3.75,
        other_fees_total_amount=1000,
        other_fees_description="Other test fees",
        more_info_url="www.moreinfo.test",
        # Relationships
        lender=lender,
    )
    session.commit()
    return instance


@pytest.fixture
def award(session):
    instance = models.Award.create(
        session,
        award_amount="123456",
        award_currency="COP",
    )
    session.commit()
    return instance


@pytest.fixture
def borrower(session):
    instance = models.Borrower.create(
        session,
        borrower_identifier=str(uuid.uuid4()),
        legal_name="",  # tests expect this to be in missing_data
        email="test@example.com",
        address="Direccion: Test Address\nCiudad: Test City\nProvincia: No provisto\nEstado: No provisto",
        legal_identifier="",
        type="Test Organization Type",
        sector="",
        size=models.BorrowerSize.NOT_INFORMED,
        declined_at=None,
        source_data={
            "nombre_entidad": "Test Entity",
            "nit": "123456789121",
            "tel_fono_entidad": "1234567890",
            "correo_entidad": "test@example.com",
            "direccion": "Test Address",
            "estado_entidad": "Test State",
            "ciudad": "Test City",
            "website": "https://example.com",
            "tipo_organizacion": "Test Organization Type",
            "tipo_de_documento": "Test Document Type",
            "numero_de_cuenta": "Test Account Number",
            "banco": "Test Bank",
            "tipo_cuenta": "Test Account Type",
            "tipo_documento_representante_legal": "Test Representative Document Type",
            "num_documento_representante_legal": "987654321",
            "nombre_representante_legal": "Test Legal Representative",
            "nacionalidad_representante_legal": "COLOMBIANO",
            "direcci_n_representante_legal": "Test Representative Address",
            "genero_representante_legal": "No Definido",
            "es_pyme": "SI",
            "regimen_tributario": "Test Tax Regime",
            "pais": "CO",
        },
        status=models.BorrowerStatus.ACTIVE,
        # Timestamps
        created_at=datetime.utcnow(),
        updated_at="2023-06-22T17:48:05.381251",
    )
    session.commit()
    return instance


@pytest.fixture
def application_uuid():
    return str(uuid.uuid4())


@pytest.fixture
def application_payload(application_uuid, award, borrower):
    return {
        "uuid": application_uuid,
        "primary_email": "test@example.com",
        "award_borrower_identifier": "test_hash_12345678",
        # Request
        "amount_requested": 10000,
        "currency": "COP",
        "repayment_months": None,
        "calculator_data": {},
        # Status
        "pending_documents": True,
        "pending_email_confirmation": True,
        # Timeline
        "borrower_declined_at": None,
        "borrower_declined_preferences_data": {},
        "borrower_declined_data": {},
        "borrower_accepted_at": None,
        "borrower_submitted_at": None,
        "lender_started_at": None,
        "lender_rejected_at": None,
        "lender_rejected_data": {},
        "lender_approved_at": None,
        "lender_approved_data": {},
        "borrower_uploaded_contract_at": None,
        "contract_amount_submitted": None,
        "secop_data_verification": {
            "legal_name": False,
            "address": True,
            "legal_identifier": True,
            "type": True,
            "size": True,
            "sector": True,
            "email": True,
        },
        "completed_in_days": None,
        "archived_at": None,
        # Relationships
        "award_id": award.id,
        "borrower": borrower,
        # Timestamps
        "created_at": datetime.utcnow(),
        "updated_at": "2023-06-26T03:14:31.572553+00:00",
    }


@pytest.fixture
def pending_application(session, application_payload, credit_product, lender):
    instance = models.Application.create(
        session,
        **application_payload,
        status=models.ApplicationStatus.PENDING,
        credit_product_id=credit_product.id,
        lender=lender,
    )
    session.commit()
    return instance


@pytest.fixture
def declined_application(session, application_payload, credit_product):
    instance = models.Application.create(
        session,
        **application_payload,
        status=models.ApplicationStatus.DECLINED,
    )
    session.commit()
    return instance


@pytest.fixture
def accepted_application(session, application_payload, credit_product):
    instance = models.Application.create(
        session,
        **application_payload,
        status=models.ApplicationStatus.ACCEPTED,
        credit_product_id=credit_product.id,
    )
    session.commit()
    return instance


@pytest.fixture
def started_application(session, application_payload, lender):
    instance = models.Application.create(
        session,
        **application_payload,
        status=models.ApplicationStatus.STARTED,
        lender=lender,
    )
    session.commit()
    return instance
